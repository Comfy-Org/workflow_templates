name: Publish to PyPI

# This workflow publishes packages to PyPI and creates GitHub releases.
# Triggers:
#   1. When pyproject.toml changes on main branch (version bump from PR merge)
#
# Features:
#   - Version change detection (prevents unnecessary publishes)
#   - Recovery mode (publishes packages out-of-sync with PyPI)
#   - Dependency order publishing (subpackages before meta package)

on:
  push:
    branches: [main]
    paths:
      - "pyproject.toml"

jobs:
  check-version-change:
    runs-on: ubuntu-latest
    # Prevent concurrent publish workflows to avoid race conditions
    concurrency:
      group: publish-workflow
      cancel-in-progress: false
    outputs:
      version-changed: ${{ steps.check.outputs.changed }}
      new-version: ${{ steps.check.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0  # Full history needed for tags and version comparison

      - name: Check if version actually changed
        id: check
        run: |
          OLD_VERSION=$(git show HEAD~1:pyproject.toml | grep -E '^\s*version\s*=' | cut -d'"' -f2)
          NEW_VERSION=$(grep -E '^\s*version\s*=' pyproject.toml | cut -d'"' -f2)

          # Check if version already exists on PyPI to prevent "File already exists" errors
          PYPI_VERSION=$(./scripts/ci/get_pypi_version.sh "comfyui-workflow-templates")

          if [ "$OLD_VERSION" = "$NEW_VERSION" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Main version unchanged ($NEW_VERSION), skipping publish"
          elif [ "$NEW_VERSION" = "$PYPI_VERSION" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version $NEW_VERSION already exists on PyPI, skipping publish"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "Version changed from $OLD_VERSION to $NEW_VERSION (PyPI has $PYPI_VERSION)"
          fi

  publish:
    needs: check-version-change
    if: needs.check-version-change.outputs.version-changed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0  # Full history needed for tags

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm ci

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Install build tooling
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install --upgrade pip build twine

      - name: Determine packages to build
        id: changed-packages
        run: |
          echo "=== Package Detection Logic ==="

          # Find the last successful publish by looking for the latest git tag
          LAST_PUBLISH_TAG=$(git tag --sort=-version:refname | head -1)
          if [ -z "$LAST_PUBLISH_TAG" ]; then
            echo "âš ï¸ No previous publish tags found, using HEAD~10 as reference"
            LAST_PUBLISH_REF="HEAD~10"
          else
            LAST_PUBLISH_REF="$LAST_PUBLISH_TAG"
            echo "ğŸ“‹ Last publish was: $LAST_PUBLISH_TAG"
          fi

          # Check what files changed since last publish (not just current commit)
          CHANGED_FILES=$(git diff --name-only "$LAST_PUBLISH_REF"..HEAD)
          echo "Files changed since last publish ($LAST_PUBLISH_REF):"
          echo "$CHANGED_FILES"

          PACKAGES=""

          # Check for package version changes since last publish
          echo -e "\n--- Checking for changed package versions since last publish ---"
          for pkg in core media_api media_video media_image media_other; do
            if echo "$CHANGED_FILES" | grep -q "packages/$pkg/pyproject.toml"; then
              # Verify the version actually changed by comparing versions
              OLD_VERSION=""
              NEW_VERSION=""
              
              # Get old version from last publish
              if git show "$LAST_PUBLISH_REF:packages/$pkg/pyproject.toml" > /dev/null 2>&1; then
                OLD_VERSION=$(git show "$LAST_PUBLISH_REF:packages/$pkg/pyproject.toml" | grep -E '^\s*version\s*=' | cut -d'"' -f2 || echo "0.0.0")
              fi
              
              # Get current version
              if [ -f "packages/$pkg/pyproject.toml" ]; then
                NEW_VERSION=$(grep -E '^\s*version\s*=' "packages/$pkg/pyproject.toml" | cut -d'"' -f2 || echo "0.0.0")
              fi
              
              if [ "$OLD_VERSION" != "$NEW_VERSION" ]; then
                PACKAGES="$PACKAGES $pkg"
                echo "âœ“ Will publish $pkg (version changed: $OLD_VERSION â†’ $NEW_VERSION)"
              else
                echo "  $pkg version unchanged ($NEW_VERSION), skipping"
              fi
            fi
          done

          # Check if root meta package version changed
          ROOT_VERSION_CHANGED=false
          if echo "$CHANGED_FILES" | grep -q "^pyproject.toml$"; then
            OLD_META_VERSION=""
            NEW_META_VERSION=""
            
            # Get old meta version
            if git show "$LAST_PUBLISH_REF:pyproject.toml" > /dev/null 2>&1; then
              OLD_META_VERSION=$(git show "$LAST_PUBLISH_REF:pyproject.toml" | grep -E '^\s*version\s*=' | cut -d'"' -f2 || echo "0.0.0")
            fi
            
            # Get current meta version
            NEW_META_VERSION=$(grep -E '^\s*version\s*=' "pyproject.toml" | cut -d'"' -f2 || echo "0.0.0")
            
            if [ "$OLD_META_VERSION" != "$NEW_META_VERSION" ]; then
              ROOT_VERSION_CHANGED=true
              echo "âœ“ Meta package version changed: $OLD_META_VERSION â†’ $NEW_META_VERSION"
            fi
          fi

          # Always build meta if root version changed OR if any subpackages need publishing
          if [ "$ROOT_VERSION_CHANGED" = "true" ] || [ -n "$PACKAGES" ]; then
            PACKAGES="$PACKAGES meta"
            if [ "$ROOT_VERSION_CHANGED" = "true" ]; then
              echo "âœ“ Will publish meta (root version changed)"
            else
              echo "âœ“ Will publish meta (subpackages changed, need meta dependency update)"
            fi
          fi

          # Recovery mode: Check for packages out-of-sync with PyPI
          # Only run if no packages detected from normal change detection
          if [ -z "$PACKAGES" ]; then
            echo -e "\n--- Recovery Mode: Checking PyPI sync status ---"

            # Check each subpackage
            for pkg_dir in packages/*/; do
              pkg_name=$(basename "$pkg_dir")
              pkg_pypi_name="comfyui-workflow-templates-${pkg_name//_/-}"

              local_version=$(./scripts/ci/get_version.sh "$pkg_dir/pyproject.toml")

              # Fetch PyPI version with robust error handling
              pypi_version=$(./scripts/ci/get_pypi_version.sh "$pkg_pypi_name")
              if [[ "$pypi_version" == "0.0.0" ]]; then
                echo "âš ï¸ Could not fetch PyPI data for $pkg_pypi_name, assuming not published"
              fi

              echo "Package $pkg_name: local=$local_version, PyPI=$pypi_version"
              if [ "$local_version" != "$pypi_version" ]; then
                PACKAGES="$PACKAGES $pkg_name"
                echo "âš ï¸ Recovery: Will publish $pkg_name (version mismatch)"
              fi
            done

            # Check meta package
            meta_local=$(./scripts/ci/get_version.sh "pyproject.toml")
            meta_pypi=$(./scripts/ci/get_pypi_version.sh "comfyui-workflow-templates")
            if [[ "$meta_pypi" == "0.0.0" ]]; then
              echo "âš ï¸ Could not fetch PyPI data for meta package, assuming not published"
            fi

            echo "Meta package: local=$meta_local, PyPI=$meta_pypi"
            if [ "$meta_local" != "$meta_pypi" ]; then
              PACKAGES="$PACKAGES meta"
              echo "âš ï¸ Recovery: Will publish meta (version mismatch)"
            fi
          fi

          # Clean up package list
          PACKAGES=$(echo $PACKAGES | tr ' ' '\n' | sort | uniq | tr '\n' ' ' | xargs)

          echo -e "\n=== Final Decision ==="
          if [ -n "$PACKAGES" ]; then
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Will build and publish: $PACKAGES"

            # Validate that we have valid version numbers for all packages to be published
            echo -e "\n--- Version Validation ---"
            for pkg in $PACKAGES; do
              if [ "$pkg" = "meta" ]; then
                version=$(./scripts/ci/get_version.sh "pyproject.toml")
                file="pyproject.toml"
              else
                version=$(./scripts/ci/get_version.sh "packages/$pkg/pyproject.toml")
                file="packages/$pkg/pyproject.toml"
              fi

              # Semantic version validation (supports pre-release and build metadata)
              if ! echo "$version" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9\-]+)?(\+[a-zA-Z0-9\-]+)?$' >/dev/null; then
                echo "âŒ Invalid version format '$version' in $file"
                echo "Expected semantic version format: x.y.z[-prerelease][+build] (e.g., 1.2.3, 1.2.3-alpha, 1.2.3+build)"
                exit 1
              fi

              echo "âœ“ $pkg: $version (valid)"
            done
          else
            echo "packages=" >> $GITHUB_OUTPUT
            echo "âœ… No packages need publishing - all versions match PyPI"
          fi

      - name: Validate bundles before publishing
        run: |
          echo "=== Pre-publish Bundle Validation ==="
          # Safety check: ensure all templates are assigned to bundles
          # This should never fail if PR validation worked, but adding as failsafe
          ./scripts/ci/validate_bundles.sh

      - name: Sync manifest and bundle assets
        run: |
          source .venv/bin/activate
          echo "=== Syncing manifests and bundle assets ==="
          python scripts/sync_bundles.py
          echo "âœ… Manifest and bundle sync complete"

      - name: Build and publish packages in dependency order
        run: |
          source .venv/bin/activate
          rm -rf dist
          mkdir dist

          PACKAGES="${{ steps.changed-packages.outputs.packages }}"
          echo "=== Building and Publishing Packages ==="
          echo "Packages to process: $PACKAGES"

          if [ -z "$PACKAGES" ]; then
            echo "âœ… No packages to build"
            exit 0
          fi

          # First build and publish non-meta packages
          echo -e "\n--- Building Subpackages ---"
          for pkg in $PACKAGES; do
            if [ "$pkg" != "meta" ]; then
              echo "ğŸ“¦ Building package: $pkg"

              if ! python -m build --outdir dist packages/$pkg; then
                echo "âŒ Failed to build package $pkg"
                exit 1
              fi

              echo "ğŸš€ Publishing $pkg to PyPI..."
              if ! twine upload dist/*$pkg* 2>/dev/null; then
                echo "âš ï¸ Upload failed for $pkg (may already exist), continuing..."
              else
                echo "âœ… Successfully published $pkg"
              fi

              rm -f dist/*$pkg*
            fi
          done

          # Then build and publish meta package
          echo -e "\n--- Building Meta Package ---"
          for pkg in $PACKAGES; do
            if [ "$pkg" = "meta" ]; then
              echo "ğŸ“¦ Building root meta package"

              if ! python -m build --outdir dist .; then
                echo "âŒ Failed to build meta package"
                exit 1
              fi

              echo "ğŸš€ Publishing meta package to PyPI..."
              if ! twine upload dist/comfyui_workflow_templates-*; then
                echo "âŒ Failed to upload meta package"
                exit 1
              fi

              echo "âœ… Successfully published meta package"
            fi
          done

          echo -e "\nğŸ‰ All packages published successfully!"
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release create "v${{ needs.check-version-change.outputs.new-version }}" \
          --title "v${{ needs.check-version-change.outputs.new-version }}" \
          --generate-notes
